#!/usr/bin/env python3
"""
Script para analizar reportes de seguridad y generar un resumen de vulnerabilidades
por herramienta y nivel de severidad.

Analiza los reportes generados por las herramientas de seguridad:
- Bandit (an√°lisis est√°tico de c√≥digo Python)
- Semgrep (an√°lisis est√°tico de c√≥digo)
- Safety (vulnerabilidades en dependencias Python)
- Trivy (vulnerabilidades en dependencias y contenedores)
- GitLeaks (secretos en c√≥digo)
- ZAP (vulnerabilidades web)
- npm audit (vulnerabilidades en dependencias Node.js)
- retire (dependencias obsoletas Node.js)

CONFIGURACI√ìN DE UMBRALES:
Por defecto, el despliegue se bloquea cuando una herramienta detecta:
- x o m√°s vulnerabilidades cr√≠ticas
- x o m√°s vulnerabilidades de alta severidad

Los umbrales pueden modificarse editando las variables:
- CRITICAL_VULN_THRESHOLD
- HIGH_VULN_THRESHOLD

CONFIGURACI√ìN DE ARCHIVOS DE REPORTES:
Los nombres de archivos de reportes pueden modificarse editando el diccionario:
- SECURITY_REPORT_FILES

Esto permite usar diferentes nombres de archivos generados por las herramientas
sin cambiar el c√≥digo fuente.

Uso:
    python3 vulnerability-summary.py [nombre_proyecto|ruta_directorio]

Ejemplos:
    python3 vulnerability-summary.py                           # Usa simply-simple-notes por defecto
    python3 vulnerability-summary.py my-project                # Busca en my-project/security-results
    python3 vulnerability-summary.py /path/to/security-results # Usa ruta absoluta
"""

import json
import os
import sys
from collections import defaultdict
from pathlib import Path

# Configuraci√≥n de umbrales de vulnerabilidades para bloqueo de despliegue
CRITICAL_VULN_THRESHOLD = 10  # N√∫mero m√°ximo de vulnerabilidades cr√≠ticas por herramienta
HIGH_VULN_THRESHOLD = 10      # N√∫mero m√°ximo de vulnerabilidades de alta severidad por herramienta

# Configuraci√≥n de nombres de archivos de reportes de seguridad
SECURITY_REPORT_FILES = {
    'bandit': 'bandit-report.json',
    'semgrep': 'semgrep-report.json',
    'safety': 'safety-results.json',
    'trivy_fs': 'trivy-fs-report.json',
    'trivy_image': 'trivy-image-report.json',
    'gitleaks': 'gitleaks-result.json',
    'zap': 'zap-report.json',
    'npm_audit': 'npm-audit-results.json',
    'retire': 'retire-results.json'
}

# Para cambiar los umbrales, modifica los valores arriba:
# Ejemplo para ambiente de desarrollo m√°s estricto:
# CRITICAL_VULN_THRESHOLD = 5
# HIGH_VULN_THRESHOLD = 10
#
# Ejemplo para ambiente de producci√≥n m√°s permisivo:
# CRITICAL_VULN_THRESHOLD = 200
# HIGH_VULN_THRESHOLD = 300
#
# Para cambiar nombres de archivos de reportes, modifica el diccionario SECURITY_REPORT_FILES:
# Ejemplo:
# SECURITY_REPORT_FILES['bandit'] = 'custom-bandit-output.json'
# SECURITY_REPORT_FILES['trivy_fs'] = 'trivy-filesystem-scan.json'
#
# O crear una configuraci√≥n personalizada completamente:
# CUSTOM_REPORT_FILES = {
#     'bandit': 'bandit-custom.json',
#     'semgrep': 'semgrep-custom.json',
#     'safety': 'safety-custom.json',
#     'trivy_fs': 'trivy-fs-custom.json',
#     'trivy_image': 'trivy-image-custom.json',
#     'gitleaks': 'gitleaks-custom.json',
#     'zap': 'zap-custom.json',
#     'npm_audit': 'npm-audit-custom.json',
#     'retire': 'retire-custom.json'
# }
# analyzer = VulnerabilityAnalyzer(reports_dir, report_files=CUSTOM_REPORT_FILES)

class VulnerabilityAnalyzer:
    def __init__(self, reports_dir, critical_threshold=None, high_threshold=None, report_files=None):
        self.reports_dir = Path(reports_dir)
        self.results = defaultdict(lambda: defaultdict(int))
        self.total_vulnerabilities = 0
        
        # Usar umbrales personalizados o valores por defecto
        self.critical_threshold = critical_threshold if critical_threshold is not None else CRITICAL_VULN_THRESHOLD
        self.high_threshold = high_threshold if high_threshold is not None else HIGH_VULN_THRESHOLD
        
        # Usar nombres de archivos personalizados o valores por defecto
        self.report_files = report_files if report_files is not None else SECURITY_REPORT_FILES.copy()
        
    def analyze_bandit_report(self):
        """Analiza el reporte de Bandit"""
        file_path = self.reports_dir / self.report_files['bandit']
        if not file_path.exists():
            return
            
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            # Bandit tiene m√©tricas por archivo con conteos de severidad
            if 'metrics' in data:
                for file_metrics in data['metrics'].values():
                    self.results['Bandit']['HIGH'] += file_metrics.get('SEVERITY.HIGH', 0)
                    self.results['Bandit']['MEDIUM'] += file_metrics.get('SEVERITY.MEDIUM', 0)
                    self.results['Bandit']['LOW'] += file_metrics.get('SEVERITY.LOW', 0)
            
            # Tambi√©n revisar los issues directos si existen
            if 'results' in data:
                for issue in data['results']:
                    severity = issue.get('issue_severity', 'UNKNOWN').upper()
                    self.results['Bandit'][severity] += 1
                    
        except Exception as e:
            print(f"Error analizando Bandit: {e}")
    
    def analyze_semgrep_report(self):
        """Analiza el reporte de Semgrep"""
        file_path = self.reports_dir / self.report_files['semgrep']
        if not file_path.exists():
            return
            
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            if 'results' in data:
                for result in data['results']:
                    # La severidad est√° en extra.severity
                    severity = result.get('extra', {}).get('severity', 'UNKNOWN').upper()
                    
                    # Mapear severidades de Semgrep
                    if severity == 'ERROR':
                        # Los ERROR de Semgrep pueden ser HIGH o MEDIUM dependiendo del impacto
                        metadata = result.get('extra', {}).get('metadata', {})
                        impact = metadata.get('impact', '').upper()
                        if impact == 'HIGH':
                            severity = 'HIGH'
                        else:
                            severity = 'MEDIUM'
                    elif severity == 'WARNING':
                        severity = 'MEDIUM'
                    elif severity == 'INFO':
                        severity = 'LOW'
                    else:
                        severity = 'UNKNOWN'
                    
                    self.results['Semgrep'][severity] += 1
                    
        except Exception as e:
            print(f"Error analizando Semgrep: {e}")
    
    def analyze_safety_report(self):
        """Analiza el reporte de Safety"""
        file_path = self.reports_dir / self.report_files['safety']
        if not file_path.exists():
            return
            
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            if 'scan_results' in data and 'vulnerabilities' in data['scan_results']:
                for vuln in data['scan_results']['vulnerabilities']:
                    # Safety usa CVE severity
                    severity = vuln.get('CVE', {}).get('severity', 'UNKNOWN').upper()
                    if severity == 'CRITICAL':
                        severity = 'CRITICAL'
                    elif severity in ['HIGH', 'IMPORTANT']:
                        severity = 'HIGH'
                    elif severity in ['MEDIUM', 'MODERATE']:
                        severity = 'MEDIUM'
                    elif severity == 'LOW':
                        severity = 'LOW'
                    
                    self.results['Safety'][severity] += 1
                    
        except Exception as e:
            print(f"Error analizando Safety: {e}")
    
    def analyze_trivy_fs_report(self):
        """Analiza el reporte de Trivy filesystem"""
        file_path = self.reports_dir / self.report_files['trivy_fs']
        if not file_path.exists():
            return
            
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            if 'Results' in data:
                for result in data['Results']:
                    if 'Vulnerabilities' in result:
                        for vuln in result['Vulnerabilities']:
                            severity = vuln.get('Severity', 'UNKNOWN').upper()
                            self.results['Trivy-FS'][severity] += 1
                            
        except Exception as e:
            print(f"Error analizando Trivy FS: {e}")
    
    def analyze_trivy_image_report(self):
        """Analiza el reporte de Trivy imagen"""
        file_path = self.reports_dir / self.report_files['trivy_image']
        if not file_path.exists():
            return
            
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            if 'Results' in data:
                for result in data['Results']:
                    if 'Vulnerabilities' in result:
                        for vuln in result['Vulnerabilities']:
                            severity = vuln.get('Severity', 'UNKNOWN').upper()
                            self.results['Trivy-Image'][severity] += 1
                            
        except Exception as e:
            print(f"Error analizando Trivy Image: {e}")
    
    def analyze_gitleaks_report(self):
        """Analiza el reporte de GitLeaks"""
        file_path = self.reports_dir / self.report_files['gitleaks']
        if not file_path.exists():
            return
            
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            # GitLeaks no tiene severidad expl√≠cita, consideramos todos como HIGH
            if isinstance(data, list):
                secret_count = len(data)
                self.results['GitLeaks']['HIGH'] += secret_count
                
        except Exception as e:
            print(f"Error analizando GitLeaks: {e}")
    
    def analyze_zap_report(self):
        """Analiza el reporte de ZAP"""
        file_path = self.reports_dir / self.report_files['zap']
        if not file_path.exists():
            return
            
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            if 'site' in data:
                for site in data['site']:
                    if 'alerts' in site:
                        for alert in site['alerts']:
                            risk_code = alert.get('riskcode', '0')
                            # Mapear riskcode de ZAP a severidad
                            if risk_code == '3':
                                severity = 'HIGH'
                            elif risk_code == '2':
                                severity = 'MEDIUM'
                            elif risk_code == '1':
                                severity = 'LOW'
                            else:
                                severity = 'INFO'
                            
                            # Contar instancias si existen
                            instances = alert.get('instances', [])
                            count = len(instances) if instances else 1
                            self.results['ZAP'][severity] += count
                            
        except Exception as e:
            print(f"Error analizando ZAP: {e}")
    
    def analyze_npm_audit_report(self):
        """Analiza el reporte de npm audit"""
        file_path = self.reports_dir / self.report_files['npm_audit']
        if not file_path.exists():
            return
            
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            if 'vulnerabilities' in data:
                for vuln_id, vuln_info in data['vulnerabilities'].items():
                    severity = vuln_info.get('severity', 'UNKNOWN').upper()
                    
                    # Mapear severidades de npm audit
                    if severity == 'CRITICAL':
                        severity = 'CRITICAL'
                    elif severity == 'HIGH':
                        severity = 'HIGH'
                    elif severity == 'MODERATE':
                        severity = 'MEDIUM'
                    elif severity == 'LOW':
                        severity = 'LOW'
                    elif severity == 'INFO':
                        severity = 'INFO'
                    
                    self.results['npm-audit'][severity] += 1
                    
        except Exception as e:
            print(f"Error analizando npm audit: {e}")
    
    def analyze_retire_report(self):
        """Analiza el reporte de retire"""
        file_path = self.reports_dir / self.report_files['retire']
        if not file_path.exists():
            return
            
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            # La estructura de retire es: {data: [file_results...]}
            if 'data' in data and isinstance(data['data'], list):
                for file_result in data['data']:
                    if 'results' in file_result:
                        for result in file_result['results']:
                            if 'vulnerabilities' in result:
                                for vuln in result['vulnerabilities']:
                                    # retire usa severity como string: low, medium, high, critical
                                    severity = vuln.get('severity', 'medium').upper()
                                    
                                    # Mapear severidades de retire
                                    if severity == 'CRITICAL':
                                        severity = 'CRITICAL'
                                    elif severity == 'HIGH':
                                        severity = 'HIGH'
                                    elif severity == 'MEDIUM':
                                        severity = 'MEDIUM'
                                    elif severity == 'LOW':
                                        severity = 'LOW'
                                    else:
                                        severity = 'MEDIUM'  # Por defecto
                                    
                                    self.results['retire'][severity] += 1
                    
        except Exception as e:
            print(f"Error analizando retire: {e}")
    
    def show_configuration_info(self):
        """Muestra informaci√≥n de configuraci√≥n al inicio del an√°lisis"""
        print(f"üîç Analizando reportes en: {self.reports_dir}")
        print(f"‚öôÔ∏è  Umbrales de bloqueo: CR√çTICAS ‚â• {self.critical_threshold}, ALTAS ‚â• {self.high_threshold}")
        
        # Verificar si hay archivos de configuraci√≥n personalizados
        custom_files = []
        for tool, filename in self.report_files.items():
            if filename != SECURITY_REPORT_FILES.get(tool, ''):
                custom_files.append(f"{tool}: {filename}")
        
        if custom_files:
            print(f"üìÇ Archivos personalizados: {', '.join(custom_files)}")
        
        print("=" * 60)
    
    def analyze_all_reports(self):
        """Analiza todos los reportes disponibles"""
        self.show_configuration_info()
        
        self.analyze_bandit_report()
        self.analyze_semgrep_report()
        self.analyze_safety_report()
        self.analyze_trivy_fs_report()
        self.analyze_trivy_image_report()
        self.analyze_gitleaks_report()
        self.analyze_zap_report()
        self.analyze_npm_audit_report()
        self.analyze_retire_report()
    
    def calculate_totals(self):
        """Calcula totales por herramienta y globales"""
        totals_by_tool = {}
        severity_totals = defaultdict(int)
        
        for tool, severities in self.results.items():
            tool_total = sum(severities.values())
            totals_by_tool[tool] = tool_total
            
            for severity, count in severities.items():
                severity_totals[severity] += count
        
        self.total_vulnerabilities = sum(totals_by_tool.values())
        return totals_by_tool, dict(severity_totals)
    
    def print_summary(self):
        """Imprime el resumen de vulnerabilidades"""
        totals_by_tool, severity_totals = self.calculate_totals()
        
        print("\nüìä RESUMEN DE VULNERABILIDADES POR HERRAMIENTA")
        print("=" * 60)
        
        # Tabla por herramienta
        header = f"{'Herramienta':<15} {'CRITICAL':<10} {'HIGH':<8} {'MEDIUM':<8} {'LOW':<8} {'INFO':<8} {'TOTAL':<8}"
        print(header)
        print("-" * len(header))
        
        for tool in sorted(self.results.keys()):
            severities = self.results[tool]
            total = totals_by_tool.get(tool, 0)
            
            critical = severities.get('CRITICAL', 0)
            high = severities.get('HIGH', 0)
            medium = severities.get('MEDIUM', 0)
            low = severities.get('LOW', 0)
            info = severities.get('INFO', 0)
            
            print(f"{tool:<15} {critical:<10} {high:<8} {medium:<8} {low:<8} {info:<8} {total:<8}")
        
        # Totales
        print("-" * len(header))
        print(f"{'TOTAL':<15} {severity_totals.get('CRITICAL', 0):<10} {severity_totals.get('HIGH', 0):<8} {severity_totals.get('MEDIUM', 0):<8} {severity_totals.get('LOW', 0):<8} {severity_totals.get('INFO', 0):<8} {self.total_vulnerabilities:<8}")
        
        # Resumen por severidad
        print(f"\nüéØ RESUMEN POR NIVEL DE SEVERIDAD")
        print("=" * 40)
        
        severity_order = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']
        for severity in severity_order:
            count = severity_totals.get(severity, 0)
            if count > 0:
                percentage = (count / self.total_vulnerabilities * 100) if self.total_vulnerabilities > 0 else 0
                print(f"{severity:<10}: {count:>4} vulnerabilidades ({percentage:>5.1f}%)")
        
        print(f"\nüî¢ TOTAL GENERAL: {self.total_vulnerabilities} vulnerabilidades encontradas")
        
        # An√°lisis de riesgo
        self.print_risk_analysis(severity_totals)
    
    def check_deployment_blocking_conditions(self):
        """Verifica si hay condiciones que bloquean el despliegue"""
        blocking_tools = []
        
        for tool, severities in self.results.items():
            critical_count = severities.get('CRITICAL', 0)
            high_count = severities.get('HIGH', 0)
            
            if critical_count >= self.critical_threshold or high_count >= self.high_threshold:
                blocking_tools.append({
                    'tool': tool,
                    'critical': critical_count,
                    'high': high_count
                })
        
        return blocking_tools
    
    def print_deployment_warning(self, blocking_tools):
        """Imprime advertencia de bloqueo de despliegue"""
        if not blocking_tools:
            return
        
        print(f"\nüö® ADVERTENCIA - DESPLIEGUE BLOQUEADO üö®")
        print("=" * 60)
        print("üõë NO SE PERMITE EL DESPLIEGUE DE LA APLICACI√ìN")
        print(f"\nRaz√≥n: Una o m√°s herramientas han detectado {self.critical_threshold} o m√°s vulnerabilidades")
        print("       cr√≠ticas o de alta severidad por herramienta.")
        print("\nüìã HERRAMIENTAS QUE BLOQUEAN EL DESPLIEGUE:")
        print("-" * 50)
        
        for tool_info in blocking_tools:
            tool = tool_info['tool']
            critical = tool_info['critical']
            high = tool_info['high']
            
            reasons = []
            if critical >= self.critical_threshold:
                reasons.append(f"{critical} vulnerabilidades CR√çTICAS")
            if high >= self.high_threshold:
                reasons.append(f"{high} vulnerabilidades de ALTA severidad")
            
            print(f"‚Ä¢ {tool:<15}: {' y '.join(reasons)}")
        
        print(f"\nüîß ACCIONES REQUERIDAS ANTES DEL DESPLIEGUE:")
        print("-" * 45)
        for tool_info in blocking_tools:
            tool = tool_info['tool']
            critical = tool_info['critical']
            high = tool_info['high']
            
            if critical >= self.critical_threshold:
                print(f"  - Corregir vulnerabilidades CR√çTICAS en {tool}")
            if high >= self.high_threshold:
                print(f"  - Corregir vulnerabilidades de ALTA severidad en {tool}")
        
        print(f"\n‚ö° El despliegue ser√° permitido cuando cada herramienta tenga:")
        print(f"   ‚Ä¢ Menos de {self.critical_threshold} vulnerabilidades cr√≠ticas")
        print(f"   ‚Ä¢ Menos de {self.high_threshold} vulnerabilidades de alta severidad")
        
    def print_risk_analysis(self, severity_totals):
        """Imprime an√°lisis de riesgo basado en las vulnerabilidades"""
        # Verificar condiciones de bloqueo de despliegue
        blocking_tools = self.check_deployment_blocking_conditions()
        self.print_deployment_warning(blocking_tools)
        
        print(f"\n‚ö†Ô∏è  AN√ÅLISIS DE RIESGO")
        print("=" * 40)
        
        critical = severity_totals.get('CRITICAL', 0)
        high = severity_totals.get('HIGH', 0)
        medium = severity_totals.get('MEDIUM', 0)
        
        if critical > 0:
            print(f"üî¥ RIESGO CR√çTICO: {critical} vulnerabilidades cr√≠ticas requieren atenci√≥n INMEDIATA")
        
        if high > 0:
            print(f"üü† RIESGO ALTO: {high} vulnerabilidades de alta severidad deben corregirse pronto")
        
        if medium > 0:
            print(f"üü° RIESGO MEDIO: {medium} vulnerabilidades de severidad media para revisi√≥n")
        
        if critical == 0 and high == 0 and medium == 0:
            print("üü¢ RIESGO BAJO: Solo vulnerabilidades de baja severidad o informativas")
        
        # Estado del despliegue
        if blocking_tools:
            print(f"\nüö´ ESTADO DEL DESPLIEGUE: BLOQUEADO")
            print(f"   Raz√≥n: {len(blocking_tools)} herramienta(s) superan el l√≠mite de vulnerabilidades")
        else:
            print(f"\n‚úÖ ESTADO DEL DESPLIEGUE: PERMITIDO")
            print("   Todas las herramientas est√°n dentro de los l√≠mites aceptables")
        
        # Recomendaciones
        print(f"\nüí° RECOMENDACIONES")
        print("-" * 20)
        
        if blocking_tools:
            print("‚Ä¢ ‚ö†Ô∏è  URGENTE: Corregir vulnerabilidades que bloquean el despliegue")
            print("‚Ä¢ Ejecutar nuevamente el an√°lisis despu√©s de las correcciones")
        
        if critical > 0 or high > 0:
            print("‚Ä¢ Priorizar la correcci√≥n de vulnerabilidades cr√≠ticas y altas")
            print("‚Ä¢ Implementar un plan de remediaci√≥n inmediato")
            if not blocking_tools:
                print("‚Ä¢ Considerar no desplegar a producci√≥n hasta resolver issues cr√≠ticos")
        
        print("‚Ä¢ Revisar y corregir secretos hardcodeados detectados por GitLeaks")
        print("‚Ä¢ Actualizar dependencias vulnerables identificadas por Safety/Trivy/npm audit")
        print("‚Ä¢ Reemplazar dependencias obsoletas detectadas por retire")
        print("‚Ä¢ Implementar controles de seguridad sugeridos por Semgrep/Bandit")
        print("‚Ä¢ Configurar headers de seguridad web identificados por ZAP")

def find_security_results_directory(project_name):
    """
    Encuentra inteligentemente el directorio de security-results para un proyecto.
    
    Busca en m√∫ltiples ubicaciones posibles:
    1. Si project_name es una ruta absoluta o contiene '/', usar directamente
    2. Buscar en ./project_name/security-results (monorepo)
    3. Buscar en ./security-results (repo individual)
    4. Buscar en el directorio actual si es 'security-results'
    5. Buscar en directorios padre (hasta 3 niveles)
    
    Args:
        project_name (str): Nombre del proyecto o ruta
        
    Returns:
        str: Ruta al directorio security-results encontrado
        
    Raises:
        SystemExit: Si no se encuentra ning√∫n directorio v√°lido
    """
    base_dir = os.path.dirname(os.path.abspath(__file__))
    current_dir = os.getcwd()
    
    # Lista de posibles ubicaciones a buscar
    possible_locations = []
    
    # 1. Si es una ruta absoluta o contiene '/', usar directamente
    if '/' in project_name or os.path.isabs(project_name):
        if os.path.isdir(project_name):
            return project_name
        possible_locations.append(project_name)
    else:
        # 2. Buscar en ./project_name/security-results (monorepo)
        monorepo_path = os.path.join(base_dir, project_name, "security-results")
        possible_locations.append(monorepo_path)
        
        # Tambi√©n buscar desde el directorio actual
        monorepo_current = os.path.join(current_dir, project_name, "security-results")
        if monorepo_current != monorepo_path:
            possible_locations.append(monorepo_current)
    
    # 3. Buscar en ./security-results (repo individual)
    repo_individual_base = os.path.join(base_dir, "security-results")
    repo_individual_current = os.path.join(current_dir, "security-results")
    possible_locations.extend([repo_individual_base, repo_individual_current])
    
    # 4. Si estamos dentro de un directorio security-results
    if os.path.basename(current_dir) == "security-results":
        possible_locations.append(current_dir)
    
    # 5. Buscar en directorios padre (hasta 3 niveles)
    for i in range(1, 4):
        parent_dir = current_dir
        for _ in range(i):
            parent_dir = os.path.dirname(parent_dir)
        
        # Buscar security-results en el padre
        parent_results = os.path.join(parent_dir, "security-results")
        possible_locations.append(parent_results)
        
        # Buscar proyecto espec√≠fico en el padre
        if not ('/' in project_name or os.path.isabs(project_name)):
            parent_project = os.path.join(parent_dir, project_name, "security-results")
            possible_locations.append(parent_project)
    
    # Verificar cada ubicaci√≥n posible
    for location in possible_locations:
        if os.path.exists(location) and os.path.isdir(location):
            # Verificar que tenga al menos un archivo de reporte
            json_files = [f for f in os.listdir(location) if f.endswith('.json')]
            if json_files:
                print(f"üìÅ Encontrado directorio de reportes: {location}")
                return location
    
    # Si no se encontr√≥ nada, mostrar error detallado
    print(f"‚ùå Error: No se encontr√≥ directorio security-results para '{project_name}'")
    print(f"\nüîç Ubicaciones buscadas:")
    for i, location in enumerate(possible_locations, 1):
        exists = "‚úÖ" if os.path.exists(location) else "‚ùå"
        print(f"  {i}. {exists} {location}")
    
    print(f"\nüí° Consejos:")
    print(f"  ‚Ä¢ Aseg√∫rate de que el proyecto '{project_name}' existe")
    print(f"  ‚Ä¢ Verifica que se haya ejecutado el an√°lisis de seguridad")
    print(f"  ‚Ä¢ El directorio debe contener archivos JSON de reportes")
    print(f"\nüìÇ Estructura esperada:")
    print(f"  Monorepo: ./{project_name}/security-results/")
    print(f"  Repo individual: ./security-results/")
    
    sys.exit(1)


def main():
    """Funci√≥n principal"""
    # Verificar si se solicita ayuda
    if len(sys.argv) > 1 and sys.argv[1] in ['-h', '--help', 'help']:
        print(__doc__)
        print("\nEjemplos de uso:")
        print("  python3 vulnerability-summary.py                           # Busca autom√°ticamente")
        print("  python3 vulnerability-summary.py simply-vulnerable-python  # Monorepo")
        print("  python3 vulnerability-summary.py current-project           # Repo individual")
        print("  python3 vulnerability-summary.py /path/to/security-results # Ruta absoluta")
        sys.exit(0)
    
    if len(sys.argv) > 1:
        project_name = sys.argv[1]
        reports_dir = find_security_results_directory(project_name)
    else:
        # Sin argumentos, buscar autom√°ticamente
        print("ÔøΩ No se especific√≥ proyecto, buscando autom√°ticamente...")
        
        # Posibles proyectos a buscar autom√°ticamente
        auto_detect_projects = ["simply-vulnerable-python", "simply-vulnerable-node", "current-project"]
        
        reports_dir = None
        project_name = None
        for project in auto_detect_projects:
            try:
                reports_dir = find_security_results_directory(project)
                project_name = project
                break
            except SystemExit:
                continue
        
        if not reports_dir:
            print("‚ùå No se pudo detectar autom√°ticamente ning√∫n proyecto con reportes")
            print("üí° Especifica el nombre del proyecto: python3 vulnerability-summary.py PROYECTO")
            sys.exit(1)
    
    project_display_name = os.path.basename(os.path.dirname(reports_dir)) if os.path.basename(reports_dir) == "security-results" else "current-project"
    print(f"üìÅ Proyecto: {project_display_name}")
    
    analyzer = VulnerabilityAnalyzer(reports_dir)
    analyzer.analyze_all_reports()
    analyzer.print_summary()
    
    # Verificar si hay condiciones de bloqueo y salir con c√≥digo de error
    blocking_tools = analyzer.check_deployment_blocking_conditions()
    if blocking_tools:
        print(f"\nüí• Ejecuci√≥n terminada con c√≥digo de error debido a vulnerabilidades que bloquean el despliegue")
        sys.exit(1)  # C√≥digo de salida 1 indica error 
    else:
        print(f"\n‚úÖ An√°lisis completado. El despliegue puede proceder.")
        sys.exit(0)  # C√≥digo de salida 0 indica √©xito

if __name__ == "__main__":
    main()